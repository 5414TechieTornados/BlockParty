#pragma config(Sensor, S4,     irSeeker,       sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-irseeker-v2.h"

const float startFirst = 0;
const float firstSecond = 0;
const float secondThird = 0;
const float thirdFourth = 0;
const float outerToTurn = 0;
const float turnDistance = 3;
const float turnToLine = 40.0;
const float lineToPark = 30.0;
const int firstMarker = 5;
const int secondMarker = 7;
const int thirdMarker = 9;

const int forward = 1;
const int backward = -1;

const float inchesToRotations = 7.851;

float distanceToEncoderValue(float distance){
	return (distance/inchesToRotations) * 360;
}

void zeroMotors(){
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	motor[motorB] = 0;
	motor[motorC] = 0;
}

void moveRobot(float distance, int direction, bool turn){
	if(turn){
		zeroMotors();

		if(direction == -1){
			nMotorEncoderTarget[motorC] = distanceToEncoderValue(distance);

			motor[motorB] = -50;
			motor[motorC] = 50;

			while(nMotorRunState[motorC] != runStateIdle){
			}
		}
		else{
			nMotorEncoderTarget[motorB] = distanceToEncoderValue(distance);

			motor[motorB] = 50;
			motor[motorC] = -50;

			while(nMotorRunState[motorB] != runStateIdle){
			}
		}
	}
	else{
		zeroMotors();

		nMotorEncoderTarget[motorB] = distanceToEncoderValue(distance) * direction;
		nMotorEncoderTarget[motorC] = distanceToEncoderValue(distance) * direction;

		motor[motorB] = 50 * direction;
		motor[motorC] = 50 * direction;

		while(nMotorRunState[motorB] != runStateIdle){
		}
	}
		zeroMotors();
}

void parkingMovement(int half){

	moveRobot(turnDistance, backward, true); //Need to change moveRobot to handle a turn

	moveRobot(turnToLine, backward, false);

	moveRobot(turnDistance, forward, true);

	moveRobot(lineToPark, forward, false);
}

void depositBlock(){
}

void differentScoringMovement(){
	int timing = 0;
	int timer = 0;


	motor[motorB] = 50;
	motor[motorC] = 50;

	while(HTIRS2readDCDir(irSeeker) != 5){
		if(timing != -1){
			//nxtDisplayBigStringAt(0, 31,"%d,%d",timing, timer);
			timing = timing + 1;
		}
	}

	zeroMotors();
	wait10Msec(500);

	//make 45 degree turn and go forward
	motor[motorB] = -50;
	motor[motorC] = -50;



	while(HTIRS2readDCDir(irSeeker) != -1){
		if(timer < timing + 50){
			//nxtDisplayBigStringAt(0, 31,"%d,%d",timing, timer);
			timer = timer + 1;
		}
		else
			break;
	}

	zeroMotors();
	wait10Msec(500);

}

int convertDistance(int distance){
	return 1;
}
/*
void scoringMovement(){
	int sensorValue = HTIRS2readDCDir(irSeeker);

	//First basket move
	moveRobot(startFirst, true);

	if(sensorValue == firstMarker){
		depositBlock();
		moveRobot(outerToTurn, false);
		parkingMovement(0);
		return;
	}

	//Second basket move
	moveRobot(firstSecond, true);

	if(sensorValue == secondMarker){
		depositBlock();
		moveRobot(firstSecond, false);
		moveRobot(outerToTurn, false);
		parkingMovement(0);
		return;
	}

	//Third basket move
	moveRobot(secondThird, true);

	if(sensorValue == thirdMarker){
		depositBlock();
		moveRobot(thirdFourth, true);
		moveRobot(outerToTurn, true);
		parkingMovement(1);
		return;
	}

	//Fourth basket move
	moveRobot(thirdFourth, true);
	depositBlock();
	moveRobot(outerToTurn, true);
	parkingMovement(1);
}
*/
task main()
{
	tHTIRS2DSPMode _mode = DSP_1200;
	differentScoringMovement();
	parkingMovement(1);

}
