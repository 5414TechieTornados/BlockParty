#pragma config(Sensor, S4,     irSeeker,       sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float startFirst = 0;
const float firstSecond = 0;
const float secondThird = 0;
const float thridFloat = 0;
const float outerToTurn = 0;
const float turnDistance = 0;
const float turnToLine = 0;
const float lineToPark = 0;
const int firstMarker = 5;
const int secondMarker = 7;
const int thirdMarker = 9;

task void depositBlock(){
}

task void moveRobot(float distance, bool direction){
}

task int convertDistance(int distance){
	return 1;
}

task void scoringMovement(){
	int sensorValue = HTIRS2readDCDir(irSeeker);

	//First basket move
	moveRobot(startFirst, true);

	if(sensorValue == firstMarker){
		depositBlock();
		moveRobot(outerToTurn, false);
		parkingMovement(0);
		return;
	}

	//Second basket move
	moveRobot(firstSecond, true);

	if(sensorValue == secondMarker){
		depositBlock();
		moveRobot(firstToSecond, false);
		moveRobot(outerToTurn, false);
		parkingMovement(0);
		return;
	}

	//Third basket move
	moveRobot(secondThird, true);

	if(sensorValue == thirdMarker){
		depositBlock();
		moveRobot(thirdToFourth, true);
		moveRobot(outerToTurn, true);
		parkingMovement(1);
		return;
	}

	//Fourth basket move
	moveRobot(thirdFourth, true);
	depositBlock();
	moveRobot(outerToTurn, true);
	parkingMovement(1);
}

task void parkingMovement(int half){
	if(half == 1){
		moveRobot(turnDistance, true) //Need to change moveRobot to handle a turn
	}
	else{
		moveRobot(turnDistance, false) //Need to change moveRobot to handle a turn
	}

	moveRobot(turnToLine, true);

	if(half ==1){
		moveRobot(turnDistance, true);
	}
	else{
		moveRobot(turnDistance, false);
	}

	moveRobot(lineToPark, true);
}


task main()
{
	scoringMovement();
	parkingMovement();

}
